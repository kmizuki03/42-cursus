# libft - 標準ライブラリ関数の再実装

## 1. 目的

本課題では、C言語の標準ライブラリ関数を一から再実装することで、低レベルなメモリ操作や文字列処理の内部動作を理解することを目的とする。また、今後のプロジェクトで使用する共通ライブラリとしての基盤を構築することも目的の一つである。

## 2. 背景

C言語の標準ライブラリ関数（`string.h`、`stdlib.h`、`ctype.h`など）は、日常的に使用するものの、その内部実装についてはブラックボックスとして扱われることが多い。本課題を通じて、これらの関数がどのようにメモリを操作し、どのようなアルゴリズムで動作しているのかを深く理解する。

## 3. 実装内容

### 3.1 文字判定関数群

`ft_isalpha`、`ft_isdigit`、`ft_isalnum`、`ft_isascii`、`ft_isprint`などの文字判定関数を実装した。ASCIIコードの範囲を利用した効率的な判定を行った。

### 3.2 文字列操作関数群

- **`ft_strlen`**: 文字列の長さを計算
- **`ft_strlcpy`、`ft_strlcat`**: 安全な文字列コピー・連結（バッファオーバーフロー対策）
- **`ft_strchr`、`ft_strrchr`**: 文字の検索
- **`ft_strncmp`**: 文字列の比較
- **`ft_strnstr`**: 部分文字列の検索

### 3.3 メモリ操作関数群

- **`ft_memset`、`ft_bzero`**: メモリの初期化
- **`ft_memcpy`、`ft_memmove`**: メモリのコピー（`memmove`はオーバーラップ対応）
- **`ft_memchr`、`ft_memcmp`**: メモリ内の検索・比較
- **`ft_calloc`**: ゼロ初期化付きメモリ確保

### 3.4 変換関数群

- **`ft_atoi`**: 文字列を整数に変換（符号、空白文字の処理を含む）
- **`ft_itoa`**: 整数を文字列に変換（動的メモリ確保）

### 3.5 文字列生成・操作関数群

- **`ft_substr`**: 部分文字列の抽出
- **`ft_strjoin`**: 文字列の連結
- **`ft_strtrim`**: 先頭・末尾の指定文字を削除
- **`ft_split`**: 文字列の分割（動的配列の生成）
- **`ft_strmapi`、`ft_striteri`**: 関数ポインタを用いた文字列変換

### 3.6 ファイル出力関数群

`ft_putchar_fd`、`ft_putstr_fd`、`ft_putendl_fd`、`ft_putnbr_fd`など、ファイルディスクリプタを指定できる出力関数を実装した。

## 4. 技術的な工夫点

### 4.1 メモリ安全性

`ft_strlcpy`や`ft_strlcat`では、バッファサイズを考慮した安全な実装を行った。また、`ft_calloc`では`malloc`と`memset`を組み合わせて、ゼロ初期化されたメモリを確保した。

### 4.2 オーバーラップ処理

`ft_memmove`では、コピー元とコピー先が重なっている場合でも正しく動作するよう、コピーの方向を判定して実装した。

### 4.3 動的メモリ管理

`ft_split`や`ft_itoa`などでは、必要なメモリサイズを事前に計算し、適切にメモリを確保する実装を行った。特に`ft_split`では、分割後の文字列数を事前にカウントすることで、メモリの無駄を削減した。

## 5. 使用方法

```bash
make
```

これにより`libft.a`が生成される。他のプロジェクトで使用する場合は、以下のようにリンクする：

```c
#include "libft.h"

// 使用例
char *str = ft_strjoin("Hello", " World");
ft_putendl_fd(str, 1);
free(str);
```

## 6. 考察

本課題を通じて、C言語の標準ライブラリ関数の内部実装を理解し、メモリ管理や文字列処理の基礎を身につけた。メモリ管理の重要性と、適切なエラーハンドリングの必要性を実感した。また、文字列操作におけるバッファオーバーフローの危険性と、関数ポインタの実用的な活用方法について理解を深めた。これらの知識は、今後のプロジェクトにおいて有用な基盤となるだろう。

