# Philosophers - 哲学者の食事問題の実装

## 1. 目的

本課題では、古典的な並行プログラミングの問題である「哲学者の食事問題（Dining Philosophers Problem）」を実装する。マルチスレッドプログラミング、デッドロックの回避、同期機構（ミューテックス、セマフォ）の理解を目的とする。

## 2. 背景

哲学者の食事問題は、1965年にエドガー・ダイクストラによって提唱された、並行プログラミングにおける典型的な問題である。この問題は、リソースの競合とデッドロックの危険性を実践的に理解するための優れた教材となっている。

### 2.1 問題の設定

- 複数の哲学者が円卓に座っている
- 各哲学者の前にフォークが1本ずつ置かれている（合計N本のフォーク、N人の哲学者）
- 哲学者は「考える」「食べる」「眠る」の3つの状態を繰り返す
- 食べるためには、左右両方のフォークを同時に持つ必要がある
- デッドロックを回避しつつ、すべての哲学者が公平に食事できるようにする

## 3. 実装内容

### 3.1 アーキテクチャ

プログラムは以下のコンポーネントで構成される：

- **メインスレッド**: 初期化とクリーンアップ
- **哲学者スレッド**: 各哲学者の動作をシミュレート（`pthread_create`で生成）
- **監視スレッド**: 哲学者の状態を監視し、死亡や食事回数の条件をチェック

### 3.2 データ構造

以下のデータ構造を定義した：

- **`t_philo`**: 各哲学者の状態（ID、食事回数、最後の食事時刻、フォークへのポインタなど）
- **`t_data`**: 共有データ（哲学者数、時間パラメータ、ミューテックス、シミュレーション状態など）

### 3.3 デッドロック回避戦略

以下の戦略を実装してデッドロックを回避した：

1. **フォークの順序付け**: 哲学者は常にIDの小さい方のフォークから取得する（循環待機の防止）
2. **ミューテックスの使用**: 各フォークをミューテックスで保護
3. **タイムアウト処理**: 食事に時間制限を設け、長時間待機する場合は処理を中断

### 3.4 同期機構

以下の同期機構を実装した：

- **フォーク用ミューテックス**: 各フォークへのアクセスを保護
- **出力用ミューテックス**: 標準出力への同時アクセスを防止
- **食事状態用ミューテックス**: 最後の食事時刻や食事回数の更新を保護
- **シミュレーション状態用ミューテックス**: シミュレーションの終了判定を保護

### 3.5 時間管理

`gettimeofday`を使用して、正確な時間計測を実装した。各哲学者の最後の食事時刻を記録し、`time_to_die`を超えた場合は死亡とみなす。

## 4. 技術的な工夫点

### 4.1 デッドロック回避

フォークの取得順序を統一することで、循環待機を防止した。これにより、デッドロックが発生しないことを数学的に保証できる。

### 4.2 公平性の確保

すべての哲学者が公平に食事できるよう、適切な待機時間とスケジューリングを実装した。

### 4.3 エラーハンドリング

以下のエラーハンドリングを実装した：

- スレッド作成の失敗検出
- ミューテックスの初期化・破棄の適切な処理
- メモリリークの防止

### 4.4 パフォーマンス

`usleep`を使用して、CPU使用率を抑制しながら、正確な時間待機を実装した。また、必要最小限のロック時間を確保することで、並行性を最大化した。

### 4.5 監視機構

独立した監視スレッドを実装し、以下の条件をチェックした：

- 哲学者の死亡（最後の食事から`time_to_die`経過）
- 全員が指定回数食事を完了（オプション）

## 5. 使用方法

```bash
# コンパイル
make

# 実行例（5人の哲学者、各パラメータはミリ秒）
./philo 5 800 200 200

# 食事回数の指定あり
./philo 5 800 200 200 7
```

### 5.1 パラメータ

1. **number_of_philosophers**: 哲学者の数
2. **time_to_die**: 食事なしで死亡するまでの時間（ミリ秒）
3. **time_to_eat**: 食事にかかる時間（ミリ秒）
4. **time_to_sleep**: 睡眠時間（ミリ秒）
5. **number_of_times_each_philosopher_must_eat**: 各哲学者が食事すべき回数（オプション）

## 6. デッドロック回避の数学的保証

フォークの取得順序を統一することで、循環待機を防止し、デッドロックが発生しないことを保証できる。これは、資源の順序付け（resource ordering）という古典的なデッドロック回避手法である。

## 7. 考察

本課題を通じて、並行プログラミングの基礎と、その難しさを実践的に学んだ。マルチスレッドプログラミングの基礎と、その難しさについて理解を深めた。特に、デッドロックの発生メカニズムと、回避方法について実践的な知識を得た。また、ミューテックスによる同期機構の実装と、競合状態（race condition）の理解と、その防止方法について学んだ。時間管理と、リアルタイムシステムの基礎についても理解した。特に、デッドロックの回避は理論的には理解していても、実際に実装するとなると多くの注意が必要であることを実感した。また、ミューテックスによる同期機構の実装は、今後のマルチスレッドプログラミングにおいて有用な知識となる。哲学者の食事問題は、並行プログラミングの典型的な問題であり、この実装経験は、より複雑な並行システムの設計においても役立つだろう。

