````markdown
# minishell - 小さなUNIXシェルの実装

## 1. 目的

本課題では、bashライクな最小シェルをC言語で実装することで、プロセス生成（`fork/execve`）、パイプ・リダイレクト、シグナル制御、トークナイズ/構文解析（AST）など、UNIXプログラミングの基礎を実践的に理解することを目的とする。

## 2. 背景

シェルは、ユーザー入力を解析してコマンドを実行し、環境変数や終了ステータスを管理する「OSとの対話窓口」である。本課題では、以下の要素を自力で組み立てる必要がある：

- 入力行の読み取り（`readline`）と履歴管理
- 予約語/演算子の字句解析（lexer）
- 構文解析（parser）とAST（抽象構文木）生成
- `|`, `>`, `<`, `>>`, `<<` 等のI/O制御
- ビルトインコマンドの実行と環境変数管理
- `SIGINT` 等のシグナルを、対話中/子プロセス中で適切に扱う

## 3. 実装内容

### 3.1 入力ループ（readline）

- プロンプト `minishell$ ` を表示し、`readline` で入力を受け取る
- 入力が空でなければ `add_history` で履歴に追加
- EOF（Ctrl-D）時は `exit` と表示して終了

### 3.2 字句解析（Lexer）

入力文字列を `t_token` の連結リストへ分解する。

- 単語トークン（`TOKEN_WORD`）
- 演算子トークン
  - パイプ: `|`
  - AND/OR: `&&`, `||`
  - リダイレクト: `<`, `>`, `>>`, `<<`（heredoc）
  - サブシェル: `(`, `)`
  - 背景実行トークン: `&`

クォート（`'` / `"`）は、後段の展開処理で区別できるようにマーカーを用いて保持し、不要な分割を防いでいる。

### 3.3 構文解析（Parser）とAST

- 単純コマンドの引数配列（`cmd->av`）とリダイレクト（`cmd->redirs`）を構築
- パイプや制御演算子（`&&`, `||`, `&`）を含む式をASTに構築
- `(` `)` は `NODE_SUBSHELL` として解析し、内部を再帰的にAST化する

### 3.4 展開（Expansion）

- 環境変数展開: `$VAR`
- 終了ステータス展開: `$?`
- `~`（チルダ）の展開
- heredoc（`<<`）は、デリミタがクォートされていない場合に限り `$VAR` / `$?` を展開する

### 3.5 実行（Executor）

- 外部コマンドは `PATH` を探索し `execve` で実行
- パイプラインは `pipe` と `dup2` を用いて各プロセスを接続
- リダイレクトは `open` / `dup2` で入出力を差し替え
- ビルトインは、必要に応じて「親プロセス側で」実行する（例: `cd`, `export`, `unset`, `exit`）

### 3.6 ビルトイン

以下を実装している：

- `echo`（`-n`対応）
- `cd`
- `pwd`
- `export`
- `unset`
- `env`
- `exit`

### 3.7 シグナル

- 対話中（プロンプト表示中）
  - `SIGINT`（Ctrl-C）で入力行を破棄して改行し、プロンプトを再表示
  - `SIGQUIT`（Ctrl-\）は無視
- 子プロセス実行中
  - `SIGINT`/`SIGQUIT` はデフォルト動作に戻し、bashに近い挙動に寄せる
- heredoc中
  - `SIGINT` で入力を中断し、heredoc生成を失敗扱いとして戻る

## 4. 技術的な工夫点

### 4.1 ASTベースの実行

パイプ・論理演算・サブシェルをASTに落とし込み、`execute_ast` の再帰で評価する構造にした。これにより、演算子優先順位（例: `|` を先に束ねる）や括弧の入れ子を扱いやすくしている。

### 4.2 親プロセスでのビルトイン実行

パイプが無い単一コマンドのビルトインは親プロセスで実行し、`cd` や `export` の効果がシェル本体に反映されるようにしている。

### 4.3 heredocの実装

heredoc はパイプを使って内容を保持し、実行時にはその読み取り側FDを `STDIN` に接続することで、ファイルを作らずに入力を供給できるようにしている。

## 5. 使用方法

### 5.1 ビルド

```bash
cd minishell
make
```

※ 環境によっては `readline` が別途必要になる（リンクエラーになる）場合がある。

bonus版（ワイルドカード展開など）をビルドする場合：

```bash
make bonus
```

### 5.2 実行

```bash
./minishell
# または
./minishell_bonus
```

### 5.3 実行例

```bash
echo hello | wc -c
export FOO=42 && echo $FOO
(cat << EOF | grep a) && echo ok
abc
aaa
EOF
```

## 6. 考察

最初は「入力を受け取って `execve` すればシェルっぽくなる」と思っていたが、実際に作り始めるとそれだけでは全然動かず、想像以上に考えることが多かった。トークナイズやASTの組み方が少しズレるだけで、パイプや `&&` / `||` の挙動が崩れてデバッグに時間がかかった。

特に難しかったのは、ビルトインを親プロセスで実行する必要があるケース（`cd` や `export` など）と、パイプや子プロセス実行時の扱いを整理する部分だった。ここを理解してからは「なぜbashでこう動くのか」が少しずつ腑に落ちてきた。

また、対話中と子プロセス実行中（heredoc含む）でシグナルの扱いを切り替えないと、Ctrl-C の挙動が不自然になったり、入力が壊れたりすることを実感した。今回の実装を通して、シェルはコマンド実行だけではなく、FD・プロセス・シグナルをまとめて状態管理するプログラムなんだと学べた。

````
