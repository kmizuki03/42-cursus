# minitalk - シグナルを用いたプロセス間通信

## 1. 目的

本課題では、UNIXシグナル（`SIGUSR1`、`SIGUSR2`）を用いて、2つのプロセス間でメッセージを送受信するプログラムを実装する。シグナルハンドリング、プロセス間通信（IPC）の基礎、ビット単位のデータ送信の実装方法を理解することを目的とする。

## 2. 背景

UNIXシグナルは、プロセス間で非同期に情報を伝達するためのメカニズムである。通常、シグナルは制御情報（プロセスの終了、エラー通知など）を伝えるために使用されるが、本課題では、シグナルを利用して任意のデータ（文字列）を送信するという、やや特殊な用途で使用する。

## 3. 実装内容

### 3.1 アーキテクチャ

プログラムは2つのコンポーネントで構成される：

- **サーバー（server）**: メッセージを受信し、標準出力に表示
- **クライアント（client）**: サーバーのプロセスIDとメッセージを受け取り、シグナルで送信

### 3.2 通信プロトコル

シグナルは本質的に1ビットの情報しか伝えられないため、文字列をビット単位で送信する必要がある。以下のプロトコルを実装した：

1. 各文字を8ビット（1バイト）に分解
2. 各ビットを`SIGUSR1`（0）または`SIGUSR2`（1）で送信
3. サーバー側でビットを再構築して文字を復元
4. 文字列の終端（`\0`）まで繰り返し

### 3.3 シグナルハンドリング

- **サーバー側**: `sigaction`を使用してシグナルハンドラを設定し、送信元のプロセスID（`siginfo_t`構造体から取得）を記録した
- **クライアント側**: 送信後の確認応答（ACK）を待つためのシグナルハンドラを実装した

### 3.4 同期機構

クライアントは各ビットを送信した後、サーバーからのACKを待ってから次のビットを送信する。これにより、データの順序を保証し、パケットロスを防ぐ。

## 4. 技術的な工夫点

### 4.1 ビット単位の送信

文字列の各文字を8ビットに分解し、最下位ビットから順に送信する実装を行った。ビットマスクとシフト演算を使用して、各ビットを抽出した。

### 4.2 状態管理

サーバー側では、現在受信中のビット数、累積された値、送信元のクライアントIDなどを静的変数やグローバル変数で管理した。`volatile sig_atomic_t`型を使用することで、シグナルハンドラとメイン処理の間で安全にデータを共有する。

### 4.3 エラーハンドリング

- 無効なプロセスIDの検証
- シグナル送信の失敗検出
- タイムアウト処理（実装によっては）

### 4.4 パフォーマンス

1文字送信するのに8回のシグナル送信が必要なため、長いメッセージの送信には時間がかかる。しかし、これはシグナルの性質上避けられない制約である。

## 5. 使用方法

```bash
# ターミナル1: サーバーを起動
./server
# プロセスIDが表示される（例: 12345）

# ターミナル2: クライアントからメッセージを送信
./client 12345 "Hello, World!"
```

サーバー側のターミナルに「Hello, World!」が表示される。

## 6. 考察

本課題を通じて、UNIXシグナルの実用的な活用方法と、プロセス間通信の基礎を学んだ。UNIXシグナルの仕組みと、シグナルハンドリングの実装方法について理解を深めた。また、プロセス間通信の基礎（特に非同期通信）と、ビット単位のデータ送信によるプロトコル設計の基礎について実践的な知識を得た。`volatile`キーワードと、シグナルセーフなプログラミングの重要性についても理解した。シグナルは本来、制御情報を伝えるためのものであるが、本課題ではそれをデータ送信に応用することで、シグナルの性質と制約を深く理解した。また、ビット単位のデータ送信という、低レベルな通信プロトコルの実装経験は、今後のネットワークプログラミングなどにおいても有用な知識となるだろう。

